use std::{
    fs,
    path::{Path, PathBuf},
};

use anyhow::{Context, Error, Ok};
use serde::Serialize;
use strum::IntoEnumIterator;
use tera::{Context as TeraCtx, Tera};

use trident_api::{
    config::{FileSystemType, PartitionType},
    storage_graph::types::{BlkDevKind, BlkDevReferrerKind},
};

mod devices;
mod filesystems;
mod partitions;
mod referrers;

// TODO: Print rules for all
// - BlkDevReferrerKind
// - BlkDevKind
// - FileSystemType
// - PartitionType

/// Returns a list of referrers kinds that should be included in the
/// documentation.
fn get_referrers() -> Vec<BlkDevReferrerKind> {
    BlkDevReferrerKind::iter()
        .filter(|k| k.document())
        // Filter the none referrer!
        .filter(|k| k != &BlkDevReferrerKind::None)
        .collect::<Vec<_>>()
}

/// Returns a list of device kinds that should be included in the
/// documentation.
fn get_devices() -> Vec<BlkDevKind> {
    BlkDevKind::iter()
        .filter(|d| d.document())
        // Filter the none device!
        .filter(|d| d != &BlkDevKind::None)
        .collect::<Vec<_>>()
}

/// Returns a list of file system types that should be included in the
/// documentation.
fn get_filesystems() -> Vec<FileSystemType> {
    FileSystemType::iter()
        .filter(|fs| fs.document())
        .collect::<Vec<_>>()
}

/// Returns a list of partition types that should be included in the
/// documentation.
fn get_part_types() -> Vec<PartitionType> {
    PartitionType::iter().collect::<Vec<_>>()
}

pub(crate) fn write(dest: Option<impl AsRef<Path>>) -> Result<(), Error> {
    let tera = Tera::new(
        PathBuf::from(file!())
            .parent()
            .unwrap()
            .join("templates/**/*")
            .to_str()
            .context("Failed to get template path")?,
    )
    .context("Failed to create Tera instance")?;

    let mut rules: Vec<RuleDefinition> = vec![
        devices::block_device_description_table(),
        referrers::referrer_description_table(),
        referrers::valid_targets_table(),
        referrers::reference_count_table(),
        referrers::reference_sharing_table(),
        devices::unique_field_value_constraints(),
        filesystems::expects_block_device_id(),
        filesystems::sources(),
        filesystems::can_be_mounted(),
        filesystems::verity_support(),
        referrers::homogeneous_references(),
        referrers::homogeneous_partition_types(),
        referrers::homogeneous_partition_sizes(),
        referrers::allowed_partition_types(),
        referrers::allowed_raid_levels(),
        partitions::valid_mount_paths(),
        partitions::matching_hash_partition(),
    ];

    #[allow(unknown_lints, clippy::needless_borrows_for_generic_args)]
    // "secretly" replace the body with the rendered section template
    rules
        .iter_mut()
        .try_for_each(|rule| {
            rule.body = tera
                .render(
                    &format!("sections/{}.md.jinja2", rule.template),
                    &TeraCtx::from_serialize(&rule)
                        .with_context(|| format!("Failed to serialize rule '{}'", rule.name))?,
                )
                .with_context(|| format!("Failed to render template for rule '{}'", rule.name))?;
            Ok(())
        })
        .context("Failed to render rule templates")?;

    let mut ctx = TeraCtx::new();
    ctx.insert("rules", &rules);

    let rendered = tera
        .render("rules.md.jinja2", &ctx)
        .context("Failed to render rules template")?;

    match dest {
        Some(dest) => fs::write(dest, rendered).context("Failed to write rules to file"),
        None => {
            println!("{}", rendered);
            Ok(())
        }
    }
}

#[derive(Serialize)]
struct RuleDefinition {
    /// Name of this rule
    name: &'static str,

    /// Template to use for this rule
    ///
    /// It should be the extensionless name of a *.md.jinja2 file in
    /// docbuilder/src/host_config/storage_rules/templates/sections
    template: &'static str,

    /// Body of the rule, the autogenerated contents.
    body: String,
}
