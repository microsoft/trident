use std::{
    fs,
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{bail, Context, Error, Result};
use enumflags2::BitFlags;
use log::{debug, error, trace, warn};
use serde::{Deserialize, Serialize};
use tempfile::NamedTempFile;

use sysdefs::tpm2::Pcr;
use trident_api::{
    error::{ReportError, ServicingError, TridentError, TridentResultExt},
    primitives::hash::Sha256Hash,
};

use crate::{
    bootloaders::{BOOT_EFI, GRUB_EFI},
    container,
    dependencies::Dependency,
    efivar,
    exe::RunAndCheck,
    path,
};

/// Path to the pcrlock directory where .pcrlock files are located.
///
/// `systemd-pcrlock` will search for .pcrlock files in a number of dir-s, but Trident will place
/// the files exclusively in this directory.
pub const PCRLOCK_DIR: &str = "/var/lib/pcrlock.d";

/// Path to the pcrlock policy JSON file. This represents the TPM 2.0 access policy that has been
/// generated by `systemd-pcrlock`.
pub const PCRLOCK_POLICY_JSON_PATH: &str = "/var/lib/systemd/pcrlock.json";

/// `/var/lib/pcrlock.d/630-boot-loader-code-shim.pcrlock.d`, where `lock-pe` measures the shim
///  bootloader binary, i.e. `/EFI/AZL{A/B}/bootx64.efi`, as recorded into PCR 4 following
///  Microsoft's Authenticode hash spec,
const BOOT_LOADER_CODE_SHIM_PCRLOCK_DIR: &str = "630-boot-loader-code-shim.pcrlock.d";

/// `/var/lib/pcrlock.d/640-boot-loader-code-sdboot.pcrlock.d`, where `lock-pe` measures the
/// systemd-boot bootloader binary, i.e. `/EFI/AZL{A/B}/grubx64.efi`, as recorded into PCR 4
/// following Microsoft's Authenticode hash spec,
const BOOT_LOADER_CODE_SDBOOT_PCRLOCK_DIR: &str = "640-boot-loader-code-sdboot.pcrlock.d";

/// `/var/lib/pcrlock.d/650-uki.pcrlock.d`, where `lock-uki` measures the UKI binary, as recorded
/// into PCR 4,
const UKI_PCRLOCK_DIR: &str = "650-uki.pcrlock.d";

/// `/var/lib/pcrlock.d/660-boot-loader-code-uki.pcrlock.d`, where `lock-pe` measures the .linux
/// section of the UKI binary, as recorded into PCR 4 following Microsoft's Authenticode hash spec,
const BOOT_LOADER_CODE_UKI_PCRLOCK_DIR: &str = "660-boot-loader-code-uki.pcrlock.d";

#[derive(Debug, Deserialize)]
struct PcrValue {
    pcr: Pcr,
}

#[derive(Debug, Deserialize)]
struct PcrPolicy {
    #[serde(rename = "pcrValues")]
    pcr_values: Vec<PcrValue>,
}

/// Generates a new pcrlock policy for the given PCRs, UKI binaries, and bootloader binaries.
pub fn generate_pcrlock_policy(
    pcrs: BitFlags<Pcr>,
    uki_binaries: Vec<PathBuf>,
    bootloader_binaries: Vec<PathBuf>,
) -> Result<(), TridentError> {
    debug!(
        "Preparing to generate a new pcrlock policy for the following PCRs: {:?}",
        pcrs.iter().map(|pcr| pcr.to_num()).collect::<Vec<_>>()
    );

    // Generate .pcrlock files for runtime OS image A
    generate_pcrlock_files(pcrs, uki_binaries, bootloader_binaries)
        .structured(ServicingError::GeneratePcrlockFiles)?;

    // Generate pcrlock policy; on A/B update, the existing binding will be automatically
    // updated with the new pcrlock policy
    generate_tpm2_access_policy(pcrs).structured(ServicingError::GenerateTpm2AccessPolicy)?;

    Ok(())
}

/// Calls a helper function `systemd-pcrlock make-policy` to generate a TPM 2.0 access policy.
/// Parses the contents of the JSON to validate that the pcrlock policy has been updated as
/// expected.
fn generate_tpm2_access_policy(pcrs: BitFlags<Pcr>) -> Result<(), Error> {
    debug!(
        "Generating a new TPM 2.0 access policy with the following PCRs: {:?}",
        pcrs.iter().map(|pcr| pcr.to_num()).collect::<Vec<_>>()
    );

    // If running inside of a container AND pcrlock.json already exists in the ROS on the host,
    // copy it from the host and into the container
    if container::is_running_in_container()
        .unstructured("Failed to determine if running in container")?
    {
        let host_root =
            container::get_host_root_path().unstructured("Failed to get host root path")?;
        let host_pcrlock_json_path = path::join_relative(host_root, PCRLOCK_POLICY_JSON_PATH);
        if host_pcrlock_json_path.exists() {
            debug!("Running inside of a container, so copying pcrlock policy JSON from the host at '{}' into the container at '{}'",
            host_pcrlock_json_path.display(),
            PCRLOCK_POLICY_JSON_PATH
        );
            fs::copy(host_pcrlock_json_path, PCRLOCK_POLICY_JSON_PATH)
                .context("Failed to copy pcrlock policy JSON from host to container")?;
        }
    }

    // TODO: IS THIS ACTUALLY HELPFUL?
    // Run predict command to view predictions, to then compare to the generated pcrlock policy
    predict().context("Failed to run 'systemd-pcrlock predict' command")?;

    make_policy(pcrs).context("Failed to run 'systemd-pcrlock make-policy' command")?;

    // Log pcrlock policy JSON contents
    let pcrlock_policy = fs::read_to_string(PCRLOCK_POLICY_JSON_PATH).context(format!(
        "Failed to read pcrlock policy JSON at path '{PCRLOCK_POLICY_JSON_PATH}'"
    ))?;
    trace!(
        "Contents of pcrlock policy JSON at '{}':\n{}",
        PCRLOCK_POLICY_JSON_PATH,
        pcrlock_policy
    );

    // If running inside of a container, copy pcrlock policy JSON onto the host
    if container::is_running_in_container()
        .unstructured("Failed to determine if running in container")?
    {
        let host_root =
            container::get_host_root_path().unstructured("Failed to get host root path")?;
        let host_pcrlock_json_path = path::join_relative(host_root, PCRLOCK_POLICY_JSON_PATH);
        debug!("Running inside of a container, so copying pcrlock policy JSON from the container at '{}' onto the host at '{}'",
            PCRLOCK_POLICY_JSON_PATH,
            host_pcrlock_json_path.display()
        );
        fs::copy(PCRLOCK_POLICY_JSON_PATH, host_pcrlock_json_path)
            .context("Failed to copy pcrlock policy JSON from container to host")?;
    }

    // Parse the policy JSON to validate that all requested PCRs are present
    let policy: PcrPolicy =
        serde_json::from_str(&pcrlock_policy).context("Failed to parse pcrlock policy JSON")?;
    let policy_pcrs: Vec<Pcr> = policy.pcr_values.iter().map(|pv| pv.pcr).collect();
    let missing_pcrs: Vec<Pcr> = pcrs
        .iter()
        .filter(|pcr| !policy_pcrs.contains(pcr))
        .collect();

    // If any requested PCRs are missing from the policy, return an error
    if !missing_pcrs.is_empty() {
        error!(
            "Some requested PCRs are missing from the generated pcrlock policy: '{:?}'",
            missing_pcrs
                .iter()
                .map(|pcr| pcr.to_num())
                .collect::<Vec<_>>()
        );
        return Err(anyhow::anyhow!(
            "Failed to generate a new TPM 2.0 access policy"
        ));
    }

    Ok(())
}

/// Runs `systemd-pcrlock log` to get the combined TPM 2.0 event log, output as a "pretty" JSON.
/// Parses the output and validates that every log entry related to `required_pcrs` has been
/// matched to a recognized boot component.
///
/// If a log entry has a null `component`, it means that there is no .pcrlock file that records
/// that specific measurement extended into the given PCR, for any boot process component. For that
/// reason, .pcrlock files are known as boot component definition files. If a log entry for a PCR
/// has its component missing, then the value of that PCR cannot be predicted and so the PCR cannot
/// be included in a pcrlock policy. Thus, this validation ensures that all .pcrlock files have
/// been added & generated, so that a valid TPM 2.0 access policy can be generated.
/// Please refer to `systemd-pcrlock` doc for additional info:
/// https://www.man7.org/linux/man-pages/man8/systemd-pcrlock.8.html.
fn validate_log(required_pcrs: BitFlags<Pcr>) -> Result<(), Error> {
    // Print out combined TPM 2.0 event log
    cel().context("Failed to print out combined TPM 2.0 event log")?;

    debug!(
        "Validating 'systemd-pcrlock log' output for required PCRs: {:?}",
        required_pcrs
            .iter()
            .map(|pcr| pcr.to_num())
            .collect::<Vec<_>>()
    );

    // Get parsed output of 'systemd-pcrlock log'
    let parsed_log = log_parsed().context("Failed to get 'systemd-pcrlock log' output")?;

    // Fetch list of entries that are related to required PCRs, with components that are not
    // recognized yet, if any
    let unrecognized = unrecognized_log_entries(parsed_log.clone(), required_pcrs)
        .context("Failed to get unrecognized log entries")?;
    if unrecognized.is_empty() {
        debug!("All entries for required PCRs have recognized .pcrlock components");
        return Ok(());
    }

    // TODO: If any entries not recognized, then extract the hash from the log, and manually
    // generate a .pcrlock file to have it recognized
    for (index, entry) in unrecognized.into_iter().enumerate() {
        // Only handle entries with a known digest (sha256) and missing component
        if let Some(sha256) = entry.sha256.as_ref() {
            let subdir = "670-manual.pcrlock.d";
            let pcrlock_file = generate_pcrlock_output_path(subdir, index);
            debug!(
                "Manually generating .pcrlock file for PCR {}, digest '{}' at '{}'",
                entry.pcr.to_num(),
                sha256.as_str(),
                pcrlock_file.display()
            );
            generate_pcrlock_file(pcrlock_file, entry.pcr, sha256.as_str().to_string())?;
        }
    }

    // Re-parse the log and check again
    let parsed_log = log_parsed().context("Failed to get 'systemd-pcrlock log' output")?;
    let unrecognized = unrecognized_log_entries(parsed_log.clone(), required_pcrs)
        .context("Failed to get unrecognized log entries")?;

    // If any entries still not recognized, issue an error
    let entries: Vec<String> = unrecognized
        .into_iter()
        .map(|entry| {
            format!(
                "pcr='{}', pcrname='{}', event='{}', sha256='{}', description='{}'",
                entry.pcr.to_num(),
                entry.pcrname.as_deref().unwrap_or("null"),
                entry.event.as_deref().unwrap_or("null"),
                entry.sha256.as_ref().map(|h| h.as_str()).unwrap_or("null"),
                entry.description.as_deref().unwrap_or("null"),
            )
        })
        .collect();

    bail!(
        "Failed to validate 'systemd-pcrlock log' output as some log entries for requested PCRs \
        cannot be matched to recognized components. Consider dropping these PCRs from the list:\n{}",
        entries.join("\n")
    );
}

/// Represents a single digest entry in a .pcrlock file.
#[derive(Serialize)]
struct DigestEntry<'a> {
    #[serde(rename = "hashAlg")] // Rename to match the .pcrlock file format
    hash_alg: &'a str,
    digest: String,
}

/// Represents a single record in a .pcrlock file.
#[derive(Serialize)]
struct Record<'a> {
    pcr: u32,
    digests: Vec<DigestEntry<'a>>,
}

/// Represents a .pcrlock file.
#[derive(Serialize)]
struct PcrLock<'a> {
    records: Vec<Record<'a>>,
}

/// Generates a single .pcrlock file at the given path, to capture one sha256 digest into a PCR.
fn generate_pcrlock_file(pcrlock_file: PathBuf, pcr: Pcr, digest: String) -> Result<()> {
    debug!(
        "Writing .pcrlock file at '{}' for PCR '{}' with SHA256 digest '{}'",
        pcrlock_file.display(),
        pcr.to_num(),
        digest
    );

    // Build the digest entry
    let digests = vec![DigestEntry {
        hash_alg: "sha256",
        digest,
    }];

    // Create the PcrLock structure with a single record
    let pcrlock = PcrLock {
        records: vec![Record {
            pcr: pcr.to_num(),
            digests,
        }],
    };

    // Ensure the target directory exists
    if let Some(parent) = pcrlock_file.parent() {
        fs::create_dir_all(parent)
            .context(format!("Failed to create directory '{}'", parent.display()))?;
    }

    // Serialize to JSON
    let json = serde_json::to_string(&pcrlock).context(format!(
        "Failed to serialize .pcrlock file '{}' to JSON",
        pcrlock_file.display()
    ))?;

    // Save to disk
    fs::write(&pcrlock_file, json.clone()).context(format!(
        "Failed to write .pcrlock file to '{}'",
        pcrlock_file.display()
    ))?;

    // Print contents of .pcrlock file
    trace!(
        "Contents of .pcrlock file at '{}':\n{}",
        pcrlock_file.display(),
        json
    );

    Ok(())
}

/// Represents a single log entry from the 'systemd-pcrlock log' output.
#[derive(Debug, Deserialize, Clone)]
struct LogEntry {
    pcr: Pcr,
    pcrname: Option<String>,
    event: Option<String>,
    sha256: Option<Sha256Hash>,
    component: Option<String>,
    description: Option<String>,
}

/// Represents the output of the 'systemd-pcrlock log' command.
#[derive(Debug, Deserialize, Clone)]
struct LogOutput {
    log: Vec<LogEntry>,
}

/// Parses the output of the 'systemd-pcrlock log' command as a LogOutput object.
fn log_parsed() -> Result<LogOutput, Error> {
    let output = Dependency::SystemdPcrlock
        .cmd()
        .arg("log")
        .arg("--json=pretty")
        .output_and_check()
        .context("Failed to run 'systemd-pcrlock log'")?;

    let parsed_log: LogOutput =
        serde_json::from_str(&output).context("Failed to parse 'systemd-pcrlock log' output")?;

    Ok(parsed_log)
}

/// Runs the `systemd-pcrlock cel` command to print out the combined TPM 2.0 event log in TCG
/// Canonical Event Log Format (CEL-JSON).
fn cel() -> Result<(), Error> {
    Dependency::SystemdPcrlock
        .cmd()
        .arg("cel")
        .run_and_check()
        .context("Failed to run 'systemd-pcrlock cel'")
}

/// Returns a list of entries from the 'systemd-pcrlock log' output that correspond to (1) PCRs
/// required for the pcrlock policy and (2) have components that are not recognized.
fn unrecognized_log_entries(
    parsed_log: LogOutput,
    required_pcrs: BitFlags<Pcr>,
) -> Result<Vec<LogEntry>, Error> {
    // Filter and log ONLY required PCR entries
    let required_entries: Vec<_> = parsed_log
        .log
        .iter()
        .filter(|entry| required_pcrs.contains(entry.pcr))
        .collect();

    debug!(
        "Filtered 'systemd-pcrlock log' entries for required PCRs: {:?}\n{:#?}",
        required_pcrs
            .iter()
            .map(|pcr| pcr.to_num())
            .collect::<Vec<_>>(),
        required_entries
    );

    // Validate that all required PCR entries have a recognized component; otherwise,
    // a PCR cannot be included into the pcrlock policy
    let unrecognized: Vec<_> = required_entries
        .into_iter()
        .filter(|entry| entry.component.is_none())
        .cloned()
        .collect();

    Ok(unrecognized)
}

/// Runs `systemd-pcrlock make-policy` command to predict the PCR state for future boots and then
/// generate a TPM 2.0 access policy, stored in a TPM 2.0 NV index. The prediction and info about
/// the used TPM 2.0 and its NV index are written to PCRLOCK_POLICY_JSON_PATH.
fn make_policy(pcrs: BitFlags<Pcr>) -> Result<(), Error> {
    debug!(
        "Running 'systemd-pcrlock make-policy' command to make a new pcrlock policy \
        with the following PCRs: {:?}",
        pcrs.iter().map(|pcr| pcr.to_num()).collect::<Vec<_>>()
    );

    // Run command directly since pcrlock may write to stderr even when a pcrlock policy is
    // successfully generated
    let mut cmd = Command::new("/usr/lib/systemd/systemd-pcrlock");
    cmd.arg("make-policy").arg(to_pcr_arg(pcrs));

    // Execute command and capture full output
    let output = cmd
        .output()
        .context("Failed to execute 'systemd-pcrlock make-policy' command")?;

    // Check exit status using standard fields
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        warn!(
            "Command 'systemd-pcrlock make-policy' failed with status {}: {}",
            output.status, stderr
        );
    }

    // Convert stdout to UTF-8
    let stdout_str = String::from_utf8(output.stdout)
        .context("Failed to convert stdout of 'systemd-pcrlock make-policy' to a string as it contains invalid UTF-8")?;
    let stderr_str = String::from_utf8(output.stderr)
        .context("Failed to convert stderr of 'systemd-pcrlock make-policy' to a string as it contains invalid UTF-8")?;

    // Log both outputs
    debug!(
        "Output of 'systemd-pcrlock make-policy':\nSTDOUT:\n{}\nSTDERR:\n{}",
        stdout_str, stderr_str
    );
    // Join stdout and stderr for parsing, since systemd-pcrlock will output to stderr even when we
    // don't get an error, e.g. when components for PCRs we don't care about aren't recognized
    let output_str = format!("{stdout_str}\n{stderr_str}");

    // Validate that TPM 2.0 access policy has been updated; only return a warning b/c on E2E rerun
    // test, policy already exists, for example
    if !output_str.contains("Calculated new PCR policy") || !output_str.contains("Updated NV index")
    {
        warn!(
            "The 'systemd-pcrlock make-policy' command did not update the PCR policy as expected. \
            Output:\n{}",
            output_str
        );
    }

    Ok(())
}

/// Runs the `systemd-pcrlock predict` command to show the prediction of the PCR state for the
/// future boots. Analyzes the TPM 2.0 event log, recognizes components, and then generates all
/// possible resulting PCR values for all combinations of component variants.
fn predict() -> Result<(), Error> {
    Dependency::SystemdPcrlock
        .cmd()
        .arg("predict")
        .run_and_check()
        .context("Failed to run 'systemd-pcrlock predict'")
}

/// Removes the previously generated pcrlock policy and deallocates the NV index.
pub fn remove_policy() -> Result<(), Error> {
    // Remove the pcrlock policy
    let mut pcrlock_policy = vec![PathBuf::from(PCRLOCK_POLICY_JSON_PATH)];

    // If running from inside a container, also remove the pcrlock policy on the host
    if container::is_running_in_container()
        .unstructured("Failed to determine if running in container")?
    {
        let host_root =
            container::get_host_root_path().unstructured("Failed to get host root path")?;
        let host_pcrlock_json_path = path::join_relative(host_root, PCRLOCK_POLICY_JSON_PATH);
        // Append this host path to vector
        pcrlock_policy.push(host_pcrlock_json_path);
    }

    for policy_path in pcrlock_policy {
        debug!(
            "Removing pcrlock JSON policy at '{}'",
            policy_path.display()
        );
        Dependency::SystemdPcrlock
            .cmd()
            .arg("remove-policy")
            .arg(format!("--policy={}", policy_path.display()))
            .run_and_check()
            .context("Failed to run 'systemd-pcrlock remove-policy'")?;
    }

    Ok(())
}

/// Converts the provided PCR bitflags into the `--pcr=` argument for `systemd-pcrlock`. Returns a
/// string with the PCR indices separated by `,`.
fn to_pcr_arg(pcrs: BitFlags<Pcr>) -> String {
    format!(
        "--pcr={}",
        pcrs.iter()
            .map(|flag| flag.to_num().to_string())
            .collect::<Vec<_>>()
            .join(",")
    )
}

/// Represents the `systemd-pcrlock lock-*` commands. Each command generates or removes specific
/// .pcrlock files based on the TPM 2.0 event log of the current or future boot covering all
/// records for a specific set of PCRs.
///
/// For more info, see the `systemd-pcrlock` docs:
/// https://www.man7.org/linux/man-pages/man8/systemd-pcrlock.8.html.
enum LockCommand {
    /// Generates .pcrlock files covering all records for PCRs 0 ("platform-code") and 2
    /// ("external-code"). Allows locking the boot process to the current version of the firmware
    /// of the system and its extension cards.
    FirmwareCode,

    /// Locks down the firmware configuration, i.e. PCRs 1 ("platform-config") and 3
    /// ("external-config").
    FirmwareConfig,

    /// Generates a .pcrlock file based on the SecureBoot policy currently enforced. Looks at
    /// SecureBoot, PK, KEK, db, dbx, dbt, dbr EFI variables and predicts their measurements to PCR
    /// 7 ("secure-boot-policy") on the next boot.
    SecureBootPolicy,

    /// Generates a .pcrlock file based on the SecureBoot authorities used to validate the boot
    /// path. Uses relevant measurements on PCR 7 ("secure-boot-policy").
    SecureBootAuthority,

    /// Generates a .pcrlock file based on the specified PE binary. Useful for predicting
    /// measurements the firmware makes to PCR 4 ("boot-loader-code") if the specified
    /// binary is part of the UEFI boot process.
    ///
    /// Used for non-UKI binaries only; UKI binaries must be locked with `lock-uki`.
    Pe {
        path: PathBuf,
        pcrlock_file: PathBuf,
    },

    /// Generates a .pcrlock file based on the specified UKI PE binary. Useful for predicting
    /// measurements the firmware makes to PCR 4 ("boot-loader-code"), and `systemd-stub` makes to
    /// PCR 11 ("kernel-boot"). Used for UKI images only; non-UKI binaries must be locked with
    /// `lock-pe`.
    Uki {
        path: PathBuf,
        pcrlock_file: PathBuf,
    },

    /// Generates a .pcrlock file based on /etc/machine-id. Useful for predicting measurements
    /// systemd-pcrmachine.service makes to PCR 15 ("system-identity").
    MachineId,

    /// Generates a .pcrlock file based on file system identity. Useful for predicting measurements
    /// systemd-pcrfs@.service makes to PCR 15 ("system-identity") for the root and var
    /// filesystems.
    FileSystem,
}

impl LockCommand {
    /// Returns the name of the subcommand for the `systemd-pcrlock` tool.
    fn subcmd_name(&self) -> &'static str {
        match self {
            Self::FirmwareCode => "lock-firmware-code",
            Self::FirmwareConfig => "lock-firmware-config",
            Self::SecureBootPolicy => "lock-secureboot-policy",
            Self::SecureBootAuthority => "lock-secureboot-authority",
            Self::MachineId => "lock-machine-id",
            Self::FileSystem => "lock-file-system",
            Self::Pe { .. } => "lock-pe",
            Self::Uki { .. } => "lock-uki",
        }
    }

    /// Runs a `systemd-pcrlock lock-*` command.
    fn run(&self) -> Result<(), Error> {
        debug!("Running 'systemd-pcrlock {}'", self.subcmd_name());
        let (path, pcrlock_file) = {
            let mut cmd_path: Option<PathBuf> = None;
            let mut cmd_pcrlock_file: Option<PathBuf> = None;

            match self {
                Self::FirmwareCode
                | Self::FirmwareConfig
                | Self::SecureBootPolicy
                | Self::SecureBootAuthority
                | Self::MachineId
                | Self::FileSystem => (),

                Self::Pe { path, pcrlock_file } | Self::Uki { path, pcrlock_file } => {
                    cmd_path = Some(path.clone());
                    cmd_pcrlock_file = Some(pcrlock_file.clone());
                }
            }

            (cmd_path, cmd_pcrlock_file)
        };

        let mut cmd = Dependency::SystemdPcrlock.cmd();
        cmd.arg(self.subcmd_name());

        if let Some(path) = path {
            cmd.arg(path);
        }

        if let Some(pcrlock_file) = pcrlock_file {
            cmd.arg(format!("--pcrlock={}", pcrlock_file.display()));
        }

        cmd.run_and_check().context(format!(
            "Failed to run 'systemd-pcrlock {}'",
            self.subcmd_name()
        ))
    }
}

/// Generates dynamically defined .pcrlock files for either (1) the current boot only or (2) the
/// current and the future boots. Calls the `systemd-pcrlock lock-*` commands to generate the
/// .pcrlock files, as well as helpers to generate the remaining .pcrlock files.
fn generate_pcrlock_files(
    // Bitflags representing the PCRs to generate .pcrlock files for,
    pcrs: BitFlags<Pcr>,
    // Vector containing paths of UKI binaries to measure via lock-uki,
    uki_binaries: Vec<PathBuf>,
    // Vector containing paths of bootloader binaries to be measured by Trident,
    bootloader_binaries: Vec<PathBuf>,
) -> Result<(), Error> {
    debug!(
        "Generating .pcrlock files for the following PCRs: {:?}",
        pcrs.iter().map(|pcr| pcr.to_num()).collect::<Vec<_>>()
    );

    // Define PCR coverage for each command
    let basic_cmds: Vec<(LockCommand, BitFlags<Pcr>)> = vec![
        (LockCommand::FirmwareCode, Pcr::Pcr0 | Pcr::Pcr2),
        (LockCommand::FirmwareConfig, Pcr::Pcr1 | Pcr::Pcr3),
        (LockCommand::SecureBootPolicy, Pcr::Pcr7.into()),
        (LockCommand::SecureBootAuthority, Pcr::Pcr7.into()),
        (LockCommand::MachineId, Pcr::Pcr15.into()),
        (LockCommand::FileSystem, Pcr::Pcr15.into()),
    ];

    // Filter and run commands
    for (cmd, cmd_pcrs) in basic_cmds {
        if !(cmd_pcrs & pcrs).is_empty() {
            cmd.run().context(format!(
                "Failed to generate .pcrlock file via '{}'",
                cmd.subcmd_name()
            ))?;
        } else {
            debug!(
                "Skipping running 'systemd-pcrlock {}' as PCRs '{:?}' are not requested",
                cmd.subcmd_name(),
                cmd_pcrs.iter().map(|pcr| pcr.to_num()).collect::<Vec<_>>()
            );
        }
    }

    // Run 'lock-uki' when PCRs 4/11 are requested
    if !(pcrs & (Pcr::Pcr4 | Pcr::Pcr11)).is_empty() {
        for (index, uki_path) in uki_binaries.clone().into_iter().enumerate() {
            let pcrlock_file = generate_pcrlock_output_path(UKI_PCRLOCK_DIR, index);
            let cmd = LockCommand::Uki {
                path: uki_path.clone(),
                pcrlock_file: pcrlock_file.clone(),
            };
            cmd.run().context(format!(
                "Failed to generate .pcrlock file via 'lock-uki' at '{}'",
                uki_path.display()
            ))?;

            trace!(
                "Contents of .pcrlock file at '{}':\n{}",
                pcrlock_file.display(),
                fs::read_to_string(&pcrlock_file).context(format!(
                    "Failed to read .pcrlock file at {}",
                    pcrlock_file.display()
                ))?
            );
        }
    } else {
        debug!("Skipping running 'systemd-pcrlock lock-uki' as PCRs 4 and 11 are not requested");
    }

    // Generate .pcrlock files when PCR 4 is requested
    if pcrs.contains(Pcr::Pcr4) {
        for (index, bootloader_path) in bootloader_binaries.into_iter().enumerate() {
            // Extract name of PE binary, to determine which dir to write to
            let bootloader_name = bootloader_path
                .file_name()
                .and_then(|name| name.to_str())
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "Failed to get file name from bootloader PE binary path '{}'",
                        bootloader_path.display()
                    )
                })?;
            let sub_dir = if bootloader_name == BOOT_EFI {
                BOOT_LOADER_CODE_SHIM_PCRLOCK_DIR
            } else if bootloader_name == GRUB_EFI {
                BOOT_LOADER_CODE_SDBOOT_PCRLOCK_DIR
            } else {
                bail!(
                    "Unexpected bootloader PE binary name '{}'. Expected '{}' or '{}'.",
                    bootloader_path.display(),
                    BOOT_EFI,
                    GRUB_EFI
                );
            };

            let pcrlock_file = generate_pcrlock_output_path(sub_dir, index);
            debug!(
                "Generating .pcrlock file at '{}' to measure bootloader PE binary at '{}'",
                pcrlock_file.display(),
                bootloader_path.display()
            );
            let cmd = LockCommand::Pe {
                path: bootloader_path.clone(),
                pcrlock_file: pcrlock_file.clone(),
            };
            cmd.run().context(format!(
                "Failed to generate .pcrlock file via '{}'",
                cmd.subcmd_name()
            ))?;
            trace!(
                "Contents of .pcrlock file at '{}':\n{}",
                pcrlock_file.display(),
                fs::read_to_string(&pcrlock_file).context(format!(
                    "Failed to read .pcrlock file at {}",
                    pcrlock_file.display()
                ))?
            );
        }
        // If SecureBoot is disabled, the authenticode of the .linux section of each UKI binary is
        // measured into PCR 4 as well.
        if !efivar::secure_boot_is_enabled() {
            for (index, uki_path) in uki_binaries.into_iter().enumerate() {
                let pcrlock_file =
                    generate_pcrlock_output_path(BOOT_LOADER_CODE_UKI_PCRLOCK_DIR, index);
                debug!(
                    "SecureBoot is disabled, so generating .pcrlock file at '{}' \
                    to measure .linux section of UKI PE binary at '{}'",
                    pcrlock_file.clone().display(),
                    uki_path.clone().display()
                );
                generate_linux_authenticode(uki_path.clone(), pcrlock_file.clone()).context(
                    format!(
                        "Failed to generate .pcrlock file at '{}' for .linux section of UKI PE binary at '{}'",
                        pcrlock_file.display(),
                        uki_path.display()
                    ),
                )?;
            }
        }
    } else {
        debug!("Skipping generating bootloader and UKI .pcrlock files as PCR 4 is not requested");
    }

    // Parse the 'systemd-pcrlock log' output to validate that every log entry has been matched to
    // a recognized boot component for all required PCRs, i.e. that all necessary .pcrlock files
    // have been added or generated
    validate_log(pcrs).context(
        "Failed to validate pcrlock log to confirm all required .pcrlock files have been generated",
    )?;

    Ok(())
}

/// Generates a full .pcrlock file path under PCRLOCK_DIR, given the sub-dir, and the index of the
/// .pcrlock file. This is needed so that each image, current and update, gets its own .pcrlock
/// file.
fn generate_pcrlock_output_path(pcrlock_subdir: &str, index: usize) -> PathBuf {
    let base = Path::new(PCRLOCK_DIR).join(pcrlock_subdir);
    base.join(format!("generated-{index}.pcrlock"))
}

/// Generates .pcrlock file to record measurement of the `.linux` section of the UKI binary,
/// as recorded into PCR 4.
fn generate_linux_authenticode(uki_path: PathBuf, pcrlock_file: PathBuf) -> Result<()> {
    // Copy UKI to a temp file
    let uki_temp = NamedTempFile::new().context("Failed to create temporary UKI file")?;
    fs::copy(&uki_path, uki_temp.path())
        .with_context(|| format!("Failed to copy UKI from {}", uki_path.display()))?;
    // Extract .linux
    let linux_temp = NamedTempFile::new().context("Failed to create temporary linux file")?;
    let linux_path = linux_temp.path().to_path_buf();
    Command::new("objcopy")
        .arg("--dump-section")
        .arg(format!(".linux={}", linux_path.display()))
        .arg(uki_temp.path())
        .run_and_check()
        .context(format!(
            "Failed to execute objcopy to extract linux section from UKI at '{}'",
            uki_temp.path().display()
        ))?;

    // Generate .pcrlock file
    let cmd = LockCommand::Pe {
        path: linux_path.clone(),
        pcrlock_file: pcrlock_file.clone(),
    };
    cmd.run().context(format!(
        "Failed to generate .pcrlock file via '{}'",
        cmd.subcmd_name()
    ))?;
    trace!(
        "Contents of .pcrlock file at '{}':\n{}",
        pcrlock_file.display(),
        fs::read_to_string(&pcrlock_file).context(format!(
            "Failed to read .pcrlock file at {}",
            pcrlock_file.display()
        ))?
    );
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    use enumflags2::make_bitflags;

    #[test]
    fn test_to_pcr_arg() {
        let pcrs = make_bitflags!(Pcr::{Pcr1 | Pcr4});
        assert_eq!(to_pcr_arg(pcrs), "--pcr=1,4".to_string());

        let single_pcr = make_bitflags!(Pcr::{Pcr7});
        assert_eq!(to_pcr_arg(single_pcr), "--pcr=7".to_string());

        let all_pcrs = BitFlags::<Pcr>::all();
        assert_eq!(
            to_pcr_arg(all_pcrs),
            "--pcr=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23".to_string()
        );
    }

    #[test]
    fn test_generate_pcrlock_output_path() {
        let index = 0;
        let expected_path = Path::new(PCRLOCK_DIR)
            .join(BOOT_LOADER_CODE_SHIM_PCRLOCK_DIR)
            .join(format!("generated-{index}.pcrlock"));
        assert_eq!(
            generate_pcrlock_output_path(BOOT_LOADER_CODE_SHIM_PCRLOCK_DIR, index),
            expected_path
        );
    }
}

#[cfg(feature = "functional-test")]
#[cfg_attr(not(test), allow(unused_imports, dead_code))]
mod functional_test {
    use super::*;

    use pytest_gen::functional_test;

    #[functional_test(feature = "helpers")]
    fn test_generate_tpm2_access_policy() {
        // Test case #0. Since no .pcrlock files have been generated yet, only 0-valued PCRs can be
        // used to generate a TPM 2.0 access policy.
        let zero_pcrs = Pcr::Pcr11 | Pcr::Pcr12 | Pcr::Pcr13;
        generate_tpm2_access_policy(zero_pcrs).unwrap();

        // Test case #1. Try to generate a TPM 2.0 access policy with all PCRs; should return an
        // error since no .pcrlock files have been generated yet.
        let pcrs = BitFlags::<Pcr>::all();
        assert_eq!(
            generate_tpm2_access_policy(pcrs)
                .unwrap_err()
                .root_cause()
                .to_string(),
            "Failed to generate a new TPM 2.0 access policy"
        );

        // Clean up the generated pcrlock policy
        fs::remove_file(PCRLOCK_POLICY_JSON_PATH).unwrap();
    }
}
