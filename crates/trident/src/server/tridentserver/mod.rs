//! Trident Harpoon gRPC server implementation.
//!
//! This module contains the implementation of the gRPC server for Trident's
//! Harpoon service. It defines the `TridentHarpoonServer` struct which
//! implements the gRPC service interface generated by Tonic from the Harpoon
//! protobuf definitions.

use std::{panic, sync::Arc, time::SystemTime};

use log::{error, info, warn, Level};
use prost_types::Timestamp;
use tokio::{
    sync::{
        mpsc::{self, UnboundedSender},
        OwnedRwLockReadGuard, OwnedRwLockWriteGuard, RwLock,
    },
    task::JoinHandle,
};
use tokio_util::sync::CancellationToken;
use tonic::{Code, Response, Status};

use harpoon::{
    servicing_response::Response as ResponseType, FileLocation, Log, LogLevel, ServicingResponse,
    Start,
};
use trident_api::error::{ErrorKind, TridentError};

use crate::{
    agentconfig::AgentConfig,
    logging::logfwd::LogForwarder,
    server::{activitytracker::ActivityTracker, support::stream::StreamWithLock},
    ExitKind, Logstream, TraceStream,
};

mod datastore;
mod harpoon_impl;
mod servicingmgr;

use servicingmgr::ServicingManager;

pub(super) struct TridentHarpoonServer {
    log_forwarder: LogForwarder,
    tracker: ActivityTracker,
    servicing_manager: ServicingManager,
    rwlock: Arc<RwLock<()>>,
    agent_config: AgentConfig,
    logstream: Logstream,
    tracestream: TraceStream,
}

/// This is the stream type for all servicing responses.
type ServicingResponseStream = StreamWithLock<Result<ServicingResponse, Status>, ()>;

impl TridentHarpoonServer {
    pub(super) fn new(
        log_forwarder: LogForwarder,
        tracker: ActivityTracker,
        agent_config: AgentConfig,
        logstream: Logstream,
        tracestream: TraceStream,
    ) -> Self {
        TridentHarpoonServer {
            log_forwarder,
            tracker,
            servicing_manager: ServicingManager::new(),
            rwlock: Arc::new(RwLock::new(())),
            agent_config,
            logstream,
            tracestream,
        }
    }

    /// Sets up log forwarding from the internal log forwarder to the gRPC
    /// streaming response.
    ///
    /// Internally spawns a background task that listens for log records from
    /// the internal [`LogForwarder`] and sends them over the provided gRPC
    /// channel as [`ServicingResponse`] messages. On success, this function
    /// returns a [`JoinHandle`] for the spawned task together with a
    /// [`CancellationToken`] that can be used by the caller to request
    /// shutdown of the forwarding task.
    ///
    /// # Errors
    ///
    /// Returns an internal gRPC [`Status`] error if the log forwarder sender
    /// channel cannot be installed (i.e. if
    /// [`LogForwarder::set_sender`](crate::LogForwarder::set_sender) returns
    /// an error). In that case, no background task is spawned and no log
    /// records will be forwarded for this stream.
    ///
    /// # Task lifecycle
    ///
    /// The spawned task runs until one of the following occurs:
    /// * The provided cancellation token is cancelled.
    /// * The internal log channel is closed and `recv` returns `None`.
    /// * Sending a log record on `grpc_log_tx` fails.
    ///
    /// When the task terminates for any reason, it attempts to clear the
    /// sender from the internal [`LogForwarder`] so that subsequent streams
    /// can install their own sender if needed.
    fn setup_log_forwarding(
        &self,
        grpc_log_tx: UnboundedSender<Result<ServicingResponse, Status>>,
    ) -> Result<(JoinHandle<()>, CancellationToken), Status> {
        // Set up log forwarding task
        let log_token = CancellationToken::new();
        let (log_tx, mut log_rx) = mpsc::unbounded_channel();

        // Set the sender in the log forwarder
        if self.log_forwarder.set_sender(log_tx).is_err() {
            error!("Failed to set log forwarder sender channel");
            return Err(Status::internal("Failed to set log forwarder"));
        }

        // Spawn log forwarding task
        let log_token_clone = log_token.clone();
        let log_forwarder_clone = self.log_forwarder.clone();
        let handle = tokio::spawn(async move {
            loop {
                tokio::select! {
                    _ = log_token_clone.cancelled() => {
                        break;
                    }

                    channel_msg = log_rx.recv() => {
                        let Some(log_record) = channel_msg else {
                            break;
                        };

                        let level = match log_record.level {
                            Level::Error => LogLevel::Error,
                            Level::Warn => LogLevel::Warn,
                            Level::Info => LogLevel::Info,
                            Level::Debug => LogLevel::Debug,
                            Level::Trace => LogLevel::Trace,
                        };

                        if let Err(err) = grpc_log_tx.send(Ok(ServicingResponse {
                            timestamp: Some(Timestamp::from(SystemTime::now())),
                            response: Some(ResponseType::Log(Log {
                                message: log_record.message,
                                level: level as i32,
                                target: log_record.target,
                                module: log_record.module,
                                location: Some(FileLocation {
                                    path: log_record.file,
                                    line: log_record.line,
                                }),
                            })),
                        })) {
                            error!("Failed to send log message in streaming response: {}", err);
                            break;
                        }
                    }
                }
            }

            log_forwarder_clone.clear_sender().unwrap_or_else(|err| {
                error!("Failed to clear log forwarder sender channel: {}", err);
            });
        });

        // Return the handle and cancellation token
        Ok((handle, log_token))
    }

    /// Tries to acquire a read lock on the server's RwLock. If the lock
    /// cannot be acquired, returns a gRPC Status indicating that the server is
    /// busy.
    fn try_acquire_read_lock(&self) -> Result<OwnedRwLockReadGuard<()>, Status> {
        self.rwlock.clone().try_read_owned().map_err(|_| {
            warn!("Trident is busy, cannot acquire read connection lock");
            Status::unavailable("Trident is busy")
        })
    }

    /// Tries to acquire a write lock on the server's RwLock. If the lock
    /// cannot be acquired, returns a gRPC Status indicating that the server is
    /// busy.
    fn try_acquire_write_lock(&self) -> Result<OwnedRwLockWriteGuard<()>, Status> {
        self.rwlock.clone().try_write_owned().map_err(|_| {
            warn!("Trident is busy, cannot acquire write connection lock");
            Status::unavailable("Trident is busy")
        })
    }

    /// Handles a servicing request by acquiring the necessary locks,
    /// setting up log forwarding, and spawning the provided servicing task.
    ///
    /// On success, returns a gRPC streaming response (`Response<ServicingResponseStream>`)
    /// that yields log messages and the final result of the servicing task.
    ///
    /// If the required read/write locks cannot be acquired (for example, when the
    /// server is busy), this returns an error `Status` such as `Status::unavailable`.
    /// It may also return other error `Status` values if log forwarding or task
    /// setup fails. In all error cases, no servicing task is spawned and no stream
    /// of responses is produced.
    fn servicing_request<F>(
        &self,
        name: &'static str,
        f: F,
    ) -> Result<Response<ServicingResponseStream>, Status>
    where
        F: FnOnce() -> Result<ExitKind, TridentError> + Send + panic::UnwindSafe + 'static,
    {
        info!("Received servicing request '{}'", name);

        // Try to acquire the connection lock in write mode
        let guard = self.try_acquire_write_lock()?;

        // Create the gRPC response channel
        let (tx, rx) = mpsc::unbounded_channel();

        // Try to acquire the servicing lock
        let Some(servicing_guard) = self.servicing_manager.try_lock_servicing() else {
            warn!("Request '{}' blocked because servicing is active", name);
            return Err(Status::unavailable("Servicing is active"));
        };

        // Set up log forwarding. Logs will be sent over the gRPC channel.
        let (log_fwd_handle, log_fwd_token) = self.setup_log_forwarding(tx.clone())?;

        // All prerequisites are met, send start response
        if let Err(err) = tx.send(Ok(ServicingResponse {
            timestamp: Some(Timestamp::from(SystemTime::now())),
            response: Some(ResponseType::Start(Start {})),
        })) {
            error!("Failed to send start response: {}", err);
            return Err(Status::internal("Failed to start processing"));
        }

        // Create a clone of the activity tracker to move into the task
        let tracker_clone = self.tracker.clone();

        let logstream = self.logstream.clone();
        let tracestream = self.tracestream.clone();

        // Spawn the servicing task
        tokio::spawn(async move {
            // Spawn the servicing task and await its completion
            let final_status =
                ServicingManager::spawn_servicing_task(servicing_guard, tracker_clone, f).await;

            // Reset logstream and tracestream server URLs, in case they were set.
            if let Err(e) = logstream.clear_server() {
                error!("Failed to clear logstream server: {}", e);
            }
            if let Err(e) = tracestream.clear_server() {
                error!("Failed to clear tracestream server: {}", e);
            }

            if let Some(ref err) = final_status.error {
                error!("Servicing request '{}' failed: {}", name, err.message);
            } else {
                info!("Servicing request '{}' completed successfully", name);
            }

            // Stop log forwarding
            log_fwd_token.cancel();

            // Await the log forwarding task to finish to ensure all relevant
            // logs have been sent.
            if let Err(err) = log_fwd_handle.await {
                error!("Log forwarder task failed: {}", err);
            }

            // Send the final status response
            if let Err(err) = tx.send(Ok(ServicingResponse {
                timestamp: Some(Timestamp::from(SystemTime::now())),
                response: Some(ResponseType::FinalStatus(final_status)),
            })) {
                error!("Failed to send control response: {}", err);
            }

            // Close the gRPC channel by dropping the sender. Only two senders
            // exist: this one and the one in the log forwarder, which has
            // already been stopped.
            drop(tx);

            info!("Request '{}' completed", name);
        });

        // Return the streaming response with the lock guard
        Ok(Response::new(StreamWithLock::new(rx, guard)))
    }

    /// Handles a read-only request by acquiring the necessary locks and
    /// executing the provided function.
    ///
    /// This helper:
    /// - Tries to acquire the connection lock in read mode.
    /// - Tries to acquire the servicing read lock, returning
    ///   [`Status::unavailable`] if servicing is currently active.
    /// - Executes the provided function `f` once the locks are held.
    ///
    /// On success, this returns `Ok(Response::new(result))`, where `result` is
    /// the value produced by `f`. If `f` returns an error, the error is logged
    /// and converted into a [`Status::internal`] error. Failures to acquire the
    /// underlying locks are returned as appropriate [`Status`] errors.
    async fn reading_request<F, R>(&self, name: &'static str, f: F) -> Result<Response<R>, Status>
    where
        F: FnOnce() -> Result<R, TridentError> + Send + 'static,
        R: Send + 'static,
    {
        info!("Received read request '{}'", name);
        // Try to acquire the connection lock in read mode. We hold a reference
        // to the lock guard to ensure it lives through the duration of the
        // request.
        let _guard = self.try_acquire_read_lock()?;

        // Try to acquire the servicing read lock
        let Some(servicing_guard) = self.servicing_manager.try_lock_reading() else {
            warn!(
                "Read request '{}' blocked because servicing is active",
                name
            );
            return Err(Status::unavailable("Servicing is active"));
        };

        // Execute the reading function
        Ok(Response::new(
            ServicingManager::spawn_reading_task(servicing_guard, f)
                .await
                .map_err(|e| {
                    error!("Reading request '{name}' failed: {e:?}");
                    trident_error_to_status(e)
                })?,
        ))
    }
}

fn trident_error_to_status(err: TridentError) -> Status {
    let code = match err.kind() {
        ErrorKind::ExecutionEnvironmentMisconfiguration(_) => Code::FailedPrecondition,
        ErrorKind::HealthChecks(_) => Code::Unknown,
        ErrorKind::Initialization(_) => Code::FailedPrecondition,
        ErrorKind::Internal(_) => Code::Internal,
        ErrorKind::InvalidInput(_) => Code::InvalidArgument,
        ErrorKind::Servicing(_) => Code::Unknown,
        ErrorKind::UnsupportedConfiguration(_) => Code::FailedPrecondition,
    };

    Status::new(code, format!("{err:?}"))
}
