#!/usr/bin/python3

# This script is a helper to establish an SSH tunnel that can be used to do a trident deployment
# on a baremetal machine in the lab using netlaunch locally.
#
# LAB ACCESS IS REQUIRED TO RUN THIS SCRIPT!
#
# It uses the Azure CLI to establish an SSH tunnel to the BMC, and then does an almost regular
# netlaunch deployment.
#
# This script is intended to be run from the root of the trident repository.
#
# The script will:
# 1. Generate a netlaunch configuration file that will be used to connect to the BMC.
# 2. Copy the miniproxy binary to the jumpbox.
# 3. Establish an SSH tunnel and start a TCP proxy on the jumpbox.
# 4. Start netlaunch locally.
#
# Miniproxy is a small utility that is used to forward TCP connections from one port to another.
# It is used to forward the BMC connection from the jumpbox to the forwarded port on the jumpbox.
# This is necessary because the SSHD is configured with `GatewayPorts no`, which means that the
# forwarded port is only accessible from the jumpbox itself. Miniproxy is used to forward the
# connection to a port that is accessible from the outside.


def delete_me_to_run():
    print(
        "This script accesses hardware in the lab and should not be run without first consulting the team chat!"
    )
    print(
        "If you are sure you want to run this script, please delete the `delete_me_to_run` function."
    )
    exit(1)


# Prevent accidental execution of this script.
delete_me_to_run()

import subprocess
import json
import time
from typing import List
import psutil
from pathlib import Path
from contextlib import contextmanager

# This is an arbitrary port that we will use for netlaunch to listen on.
LISTEN_HTTP_PORT_LOCAL = 32365

# This specific port is open on the jumpbox to allow incoming connections!
LISTEN_HTTP_PORT_REMOTE = 8100

# IP of the BMC
BMC_IP = "10.8.3.20"
# Port of the BMC's Redfish service
BMC_REDFISH_PORT = 443
# SSH port of the BMC
BMC_SSH_PORT = 22
# COM PORT for the server's serial console
BMC_SERIAL_PORT = "com2"

# This is the port that netlaunch will use to connect to the BMC for redfish.
BMC_REDFISH_PORT_LOCAL = 32555
# This is the port that netlaunch will use to connect to the BMC over SSH.
BMC_SHH_PORT_LOCAL = 32556


# These are the details of the jumpbox that we will use to establish the SSH tunnel.
JUMPBOX_SUBSCRIPTION = "f18e9c89-62a2-4c08-95cf-12d482634db4"
JUMPBOX_RESOURCE_GROUP = "b37-westus3-labs-rg"
JUMPBOX_NAME = "b37-westus3-arc-devjump"
JUMPBOX_IP = "10.249.132.133"

BAREMETAL_MACHINE_IP = "10.8.4.50/23"
BAREMETAL_MACHINE_GATEWAY = "10.8.4.1"
BAREMETAL_MACHINE_DEFAULT_INTERFACE = "eth0"


def recursive_kill(proc: int):
    """Given a process ID, kill the process and all its children."""
    psutil_proc = psutil.Process(proc)
    print("")
    print(f"Terminating process {psutil_proc.name()}[{proc}]")
    for child in psutil_proc.children(recursive=True):
        print(f"Terminating child process {child.name()}[{child.pid}]")
        child.kill()
    psutil_proc.kill()


@contextmanager
def background_process(cmd: List[str]):
    """Run a command in the background and yield the process object. On exit,
    kill the process and all its children and wait for it to finish."""
    print(f"Running command: {cmd[0]}")
    proc = subprocess.Popen(cmd)
    print(f"Started process {cmd[0]}[{proc.pid}]")
    try:
        yield proc
    finally:
        recursive_kill(proc.pid)
        proc.wait()


def get_ssh_command_base() -> List[str]:
    """Get the base command to establish an SSH connection to the jumpbox."""
    return [
        "az",
        "ssh",
        "arc",
        "--subscription",
        JUMPBOX_SUBSCRIPTION,
        "--resource-group",
        JUMPBOX_RESOURCE_GROUP,
        "--name",
        JUMPBOX_NAME,
        "--",
    ]


def get_secret_value(keyvault: str, secret: str) -> str:
    """Get the value of a secret from an Azure Key Vault."""
    res = subprocess.run(
        [
            "az",
            "keyvault",
            "secret",
            "show",
            "--name",
            secret,
            "--vault-name",
            keyvault,
        ],
        capture_output=True,
        check=True,
        text=True,
    )
    return json.loads(res.stdout)["value"]


bmc_username = get_secret_value("kvAfoStaging", "j25-bmc-username")
bmc_password = get_secret_value("kvAfoStaging", "j25-bmc-password")

netlaunch_config_file = Path("./input/baremetal-netlaunch.yaml")

contents = f"""# This file is generated by {__file__}
netlaunch:
  bmc:
    # Connect to localhost because we will establish an SSH tunnel to the BMC.
    ip: "localhost"
    # Connect to the local port that we will forward to the BMC's Redfish service.
    port: {BMC_REDFISH_PORT_LOCAL}
    username: "{bmc_username}"
    password: "{bmc_password}"
    # Set up the serial-over-SSH connection to the BMC.
    serialOverSsh:
      # Connect to forwarded port.
      sshPort: {BMC_SHH_PORT_LOCAL}
      comPort: {BMC_SERIAL_PORT}
      output:  "baremetal-serial.log"
  # Instruct netlaunch to tell trident and the BMC to connect to this address. (The jumpbox)
  announceIp: "{JUMPBOX_IP}"
  announcePort: {LISTEN_HTTP_PORT_REMOTE}

# Set up the initial network on the baremetal machine.
iso:
  preTridentScript: |
    ip addr add {BAREMETAL_MACHINE_IP} dev {BAREMETAL_MACHINE_DEFAULT_INTERFACE}
    ip route add default via {BAREMETAL_MACHINE_GATEWAY} dev {BAREMETAL_MACHINE_DEFAULT_INTERFACE}
"""

netlaunch_config_file.write_text(contents)
print(f"Generated {netlaunch_config_file}:\n{contents}")

print("Copying miniproxy to the jumpbox...")
with open("bin/miniproxy", "rb") as miniproxy:
    copy_cmd = get_ssh_command_base()
    # Write the miniproxy binary to the jumpbox via stdin and make it
    # executable.
    copy_cmd.extend(
        [
            "cat - > ~/miniproxy && chmod +x ~/miniproxy",
        ]
    )
    # Feed in the miniproxy binary to the stdin of the SSH command.
    subprocess.run(
        copy_cmd,
        stdin=miniproxy,
        check=True,
        stdout=subprocess.DEVNULL,
    )

print("Establishing SSH tunnel to BMC...")
tunnel_command = get_ssh_command_base()
forwarding_params = [
    "-R",
    f"{LISTEN_HTTP_PORT_LOCAL}:localhost:{LISTEN_HTTP_PORT_LOCAL}",
    "-L",
    f"{BMC_REDFISH_PORT_LOCAL}:{BMC_IP}:{BMC_REDFISH_PORT}",
    "-L",
    f"{BMC_SHH_PORT_LOCAL}:{BMC_IP}:{BMC_SSH_PORT}",
    f"./miniproxy -s {LISTEN_HTTP_PORT_REMOTE} -d {LISTEN_HTTP_PORT_LOCAL}",
]

print(f"SSH Tunnel settings: {' '.join(forwarding_params)}")

tunnel_command.extend(forwarding_params)

with background_process(tunnel_command) as ssh_tunnel:
    # Wait for the tunnel to be established. We *should* do this by reading the
    # output of the SSH command instead, but that's a bit more complicated.
    time.sleep(5)
    # time.sleep(3600)

    # Start netlaunch
    subprocess.run(
        [
            "make",
            "run-netlaunch",
            f"NETLAUNCH_CONFIG={netlaunch_config_file}",
            f"NETLAUNCH_PORT={LISTEN_HTTP_PORT_LOCAL}",
        ],
        check=True,
    )
