#!/usr/bin/python3

# This script is a helper to establish an SSH tunnel that can be used to do a Trident deployment
# on a baremetal machine in the lab using netlaunch locally.
#
# LAB ACCESS IS REQUIRED TO RUN THIS SCRIPT!
#
# It uses the Azure CLI to establish an SSH tunnel to the BMC, and then does an almost regular
# netlaunch deployment.
#
# This script is intended to be run from the root of the Trident repository.
#
# The script will:
# 1. Generate a netlaunch configuration file that will be used to connect to the BMC.
# 2. Copy the miniproxy binary to the jumpbox.
# 3. Establish an SSH tunnel and start a TCP proxy on the jumpbox.
# 4. Start netlaunch locally.
#
# Miniproxy is a small utility that is used to forward TCP connections from one port to another.
# It is used to forward the BMC connection from the jumpbox to the forwarded port on the jumpbox.
# This is necessary because the SSHD is configured with `GatewayPorts no`, which means that the
# forwarded port is only accessible from the jumpbox itself. Miniproxy is used to forward the
# connection to a port that is accessible from the outside.
#
#
# More info about lab access:
# https://dev.azure.com/msazuredev/AzureForOperatorsIndustry/_wiki/wikis/AzureForOperatorsIndustry.wiki/23997/AEP-Labs-on-prem-access


def delete_me_to_run():
    print(
        "This script accesses hardware in the lab and should not be run without first consulting the team chat!"
    )
    print(
        "If you are sure you want to run this script, please delete the `delete_me_to_run` function."
    )
    exit(1)


# Prevent accidental execution of this script.
delete_me_to_run()

import inspect
import json
import logging
import psutil
import signal
import subprocess
import time
import threading

from contextlib import contextmanager
from pathlib import Path
from typing import List

# This is an arbitrary port that we will use for netlaunch to listen on.
LISTEN_HTTP_PORT_LOCAL = 32365

# This specific port is open on the jumpbox to allow incoming connections!
LISTEN_HTTP_PORT_REMOTE = 8100

# IP of the BMC
BMC_IP = "10.8.3.20"
# Port of the BMC's Redfish service
BMC_REDFISH_PORT = 443
# SSH port of the BMC
BMC_SSH_PORT = 22
# COM PORT for the server's serial console
BMC_SERIAL_PORT = "com2"

# This is the port that netlaunch will use to connect to the BMC for redfish.
BMC_REDFISH_PORT_LOCAL = 32555
# This is the port that netlaunch will use to connect to the BMC over SSH.
BMC_SHH_PORT_LOCAL = 32556


# These are the details of the jumpbox that we will use to establish the SSH tunnel.
JUMPBOX_SUBSCRIPTION = "f18e9c89-62a2-4c08-95cf-12d482634db4"
JUMPBOX_RESOURCE_GROUP = "b37-westus3-labs-rg"
JUMPBOX_NAME = "b37-westus3-aep-azl3-vm"
JUMPBOX_IP = "10.249.132.138"

BAREMETAL_MACHINE_IP = "10.8.4.50/23"
BAREMETAL_MACHINE_GATEWAY = "10.8.4.1"
BAREMETAL_MACHINE_DEFAULT_INTERFACE = "eth0"
BAREMETAL_MACHINE_HTTPS_PROXY = "http://172.16.1.10:3128"


logging.basicConfig(level=logging.INFO)
log = logging.getLogger("lab-netlaunch")


def recursive_kill(proc: int, signal_type: signal.Signals = signal.SIGINT):
    """Given a process ID, kill the process and all its children."""
    psutil_proc = psutil.Process(proc)
    log.info(
        f"Sending signal {signal_type.name} to process {psutil_proc.name()}[{proc}]"
    )
    for child in psutil_proc.children(recursive=True):
        log.info(
            f"Sending signal {signal_type.name} to child process {child.name()}[{child.pid}]"
        )
        child.send_signal(signal_type)
    psutil_proc.send_signal(signal_type)


@contextmanager
def background_process(cmd: List[str], **kwargs):
    """Run a command in the background and yield the process object. On exit,
    kill the process and all its children and wait for it to finish."""
    log.info(f"Running command: {cmd[0]}")
    proc = subprocess.Popen(cmd, text=True, **kwargs)
    log.info(f"Started process {cmd[0]}[{proc.pid}]")
    try:
        yield proc
    finally:
        if proc.poll() is not None:
            log.info(
                f"Process {cmd[0]}[{proc.pid}] already exited with code {proc.returncode}."
            )
            return

        log.info(f"Killing process '{cmd[0]}' and all its children...")
        recursive_kill(proc.pid)
        log.info(f"Waiting for process {cmd[0]}[{proc.pid}] to finish...")
        start_time = time.time()
        while proc.poll() is None and time.time() - start_time < 10:
            time.sleep(0.2)
        if proc.poll() is None:
            log.warning(
                f"Process {cmd[0]}[{proc.pid}] did not exit after SIGINT, sending SIGKILL..."
            )
            recursive_kill(proc.pid, signal.SIGKILL)
        else:
            log.info(
                f"Process {cmd[0]}[{proc.pid}] exited graciously with code {proc.returncode}"
            )
        proc.wait()


def get_ssh_command_base() -> List[str]:
    """Get the base command to establish an SSH connection to the jumpbox."""
    return [
        "az",
        "ssh",
        "arc",
        "--subscription",
        JUMPBOX_SUBSCRIPTION,
        "--resource-group",
        JUMPBOX_RESOURCE_GROUP,
        "--name",
        JUMPBOX_NAME,
        "--",
    ]


def get_secret_value(keyvault: str, secret: str) -> str:
    """Get the value of a secret from an Azure Key Vault."""
    res = subprocess.run(
        [
            "az",
            "keyvault",
            "secret",
            "show",
            "--name",
            secret,
            "--vault-name",
            keyvault,
        ],
        capture_output=True,
        check=True,
        text=True,
    )
    return json.loads(res.stdout)["value"]


def generate_netlaunch_config() -> Path:
    bmc_username = get_secret_value("kvAfoStaging", "j25-bmc-username")
    bmc_password = get_secret_value("kvAfoStaging", "j25-bmc-password")

    netlaunch_config_file = Path("./input/baremetal-netlaunch.yaml")

    contents = f"""
    # This file is generated by {__file__}
    netlaunch:
      bmc:
        # Connect to localhost because we will establish an SSH tunnel to the BMC.
        ip: "localhost"
        # Connect to the local port that we will forward to the BMC's Redfish service.
        port: {BMC_REDFISH_PORT_LOCAL}
        username: "{bmc_username}"
        password: "{bmc_password}"
        # Set up the serial-over-SSH connection to the BMC.
        serialOverSsh:
          # Connect to forwarded port.
          sshPort: {BMC_SHH_PORT_LOCAL}
          comPort: {BMC_SERIAL_PORT}
          output:  "baremetal-serial.log"
      # Instruct netlaunch to tell Trident and the BMC to connect to this address. (The jumpbox)
      announceIp: "{JUMPBOX_IP}"
      announcePort: {LISTEN_HTTP_PORT_REMOTE}
    
    # Set up the initial network on the baremetal machine.
    iso:
      preTridentScript: |
        ip addr add {BAREMETAL_MACHINE_IP} dev {BAREMETAL_MACHINE_DEFAULT_INTERFACE}
        ip route add default via {BAREMETAL_MACHINE_GATEWAY} dev {BAREMETAL_MACHINE_DEFAULT_INTERFACE}
        while true; do
            curl -s -o /dev/null "http://{JUMPBOX_IP}:{LISTEN_HTTP_PORT_REMOTE}" && break
            sleep 1
        done

      serviceOverride: |
        [Service]
        Environment="{BAREMETAL_MACHINE_HTTPS_PROXY}"
    """
    contents = inspect.cleandoc(contents)
    log.info(f"Generated {netlaunch_config_file}:\n{contents}")
    netlaunch_config_file.write_text(contents)
    return netlaunch_config_file


def copy_miniproxy_to_jumpbox():
    log.info("Copying miniproxy to the jumpbox...")
    with open("bin/miniproxy", "rb") as miniproxy:
        copy_cmd = get_ssh_command_base()
        # Write the miniproxy binary to the jumpbox via stdin and make it
        # executable.
        copy_cmd.extend(
            [
                "killall miniproxy && cat - > ~/miniproxy && chmod +x ~/miniproxy",
            ]
        )
        # Feed in the miniproxy binary to the stdin of the SSH command.
        subprocess.run(
            copy_cmd,
            stdin=miniproxy,
            check=True,
            text=True,
        )


def make_tunnel_command() -> List[str]:
    tunnel_command = get_ssh_command_base()
    forwarding_params = [
        "-R",
        f"{LISTEN_HTTP_PORT_LOCAL}:localhost:{LISTEN_HTTP_PORT_LOCAL}",
        "-L",
        f"{BMC_REDFISH_PORT_LOCAL}:{BMC_IP}:{BMC_REDFISH_PORT}",
        "-L",
        f"{BMC_SHH_PORT_LOCAL}:{BMC_IP}:{BMC_SSH_PORT}",
        f"./miniproxy -l {LISTEN_HTTP_PORT_REMOTE} -f {LISTEN_HTTP_PORT_LOCAL}",
    ]

    log.info(f"SSH Tunnel settings: {' '.join(forwarding_params)}")

    tunnel_command.extend(forwarding_params)
    return tunnel_command


def wait_for_ssh_tunnel(tunnel: subprocess.Popen, timeout: float = 15) -> None:
    """Wait for the SSH tunnel to be established."""
    log.info("Waiting for SSH tunnel to be established...")
    start_time = time.time()
    while tunnel.poll() is None:
        if time.time() - start_time > timeout:
            log.error("SSH tunnel did not establish within the timeout period.")
            raise TimeoutError(
                "SSH tunnel did not establish within the timeout period."
            )

        line = tunnel.stderr.readline()
        if not line:
            continue

        if "Failed to listen" in line:
            log.error(f"SSH tunnel failed to establish: {line.strip()}")
            raise RuntimeError(f"SSH tunnel failed to establish: {line.strip()}")

        if "Listening..." in line:
            log.info(f"SSH tunnel established: {line.strip()}")
            return


sigint_received = False


def handle_sigint(signum, frame):
    global sigint_received
    sigint_received = True
    raise KeyboardInterrupt("Received SIGINT, shutting down gracefully...")


signal.signal(signal.SIGINT, handle_sigint)


class OutputReader:
    def __init__(self, proc: subprocess.Popen, name: str = "OutputReader"):
        self.log = logging.getLogger(name)
        self.proc = proc
        self.stderr_thread = threading.Thread(target=self._read_error, daemon=True)
        self.stdout_thread = threading.Thread(target=self._read_output, daemon=True)
        self.stderr_thread.start()
        self.stdout_thread.start()

    def _read_output(self):
        try:
            while self.proc.poll() is None:
                line = self.proc.stdout.readline()
                if not line or sigint_received:
                    break
                self.log.info(line.strip())
        except Exception as e:
            log.error(f"Error reading output: {e}")

    def _read_error(self):
        try:
            while self.proc.poll() is None:
                line = self.proc.stderr.readline()
                if not line or sigint_received:
                    break
                self.log.info(line.strip())
        except Exception as e:
            log.error(f"Error reading error output: {e}")


def deploy(netlaunch_config_file: Path):
    log.info("Establishing SSH tunnel to BMC...")
    tunnel_command = make_tunnel_command()

    with background_process(
        tunnel_command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    ) as ssh_tunnel:
        wait_for_ssh_tunnel(ssh_tunnel)
        log.info("SSH tunnel established successfully.")
        reader = OutputReader(ssh_tunnel, "SSH-TUNNEL")

        # Start netlaunch
        subprocess.run(
            [
                "make",
                "run-netlaunch",
                f"NETLAUNCH_CONFIG={netlaunch_config_file}",
                f"NETLAUNCH_PORT={LISTEN_HTTP_PORT_LOCAL}",
            ],
            check=True,
        )

        while True:
            time.sleep(60)


def main():
    try:
        nl_cfg = generate_netlaunch_config()
        copy_miniproxy_to_jumpbox()
        deploy(nl_cfg)
    except KeyboardInterrupt:
        log.warning("Received KeyboardInterrupt, shutting down...")


if __name__ == "__main__":
    main()
