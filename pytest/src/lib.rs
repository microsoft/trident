use std::env;
use std::path::PathBuf;
use std::{
    fs::{self, File},
    io::Write,
    path::Path,
};

use itertools::Itertools;

/// Used by `inventory` to collect test case metadata and process them on per
/// crate basis in `generate_pytest_wrappers`.
#[derive(Default, Debug)]
pub struct TestCaseMetadata<'a> {
    pub module: &'a str,
    pub function: &'a str,
    pub negative: bool,
    pub feature: &'a str,
    pub type_: &'a str,
}

/// Internal represntation of the test case metadata, extracted from `TestCaseMetadata`.
#[derive(Default, Debug)]
struct TestCaseMetadataInt<'a> {
    pub crate_: &'a str,
    pub module: &'a str,
    pub function: &'a str,
    pub type_: &'a str,
    pub negative: bool,
    pub feature: &'a str,
}

// Registers `TestCaseMetadata` with `inventory` for further processing.
inventory::collect!(TestCaseMetadata<'static>);

/// Creates a list of pytest markers from provided values.
fn create_markers(marker_values: Vec<&str>) -> Vec<String> {
    let mut markers: Vec<_> = marker_values
        .iter()
        .map(|value| format!("@pytest.mark.{}", value))
        .collect();

    markers.sort();
    markers
}

/// Generates pytest test class prefix
fn serialize_pytest_wrapper_for_test_class(
    test_class_name: &str,
    test_cases: Vec<TestCaseMetadataInt>,
) -> String {
    let markers = create_markers(vec![
        test_cases[0].crate_,
        test_cases[0].module.replace("::", "_").as_str(),
    ])
    .join("\n");
    let class_prefix = format!(
        indoc::indoc!(
            r#"
                """Autogenerated from Rust code. Do not edit manually. Run `make generate-pytest-wrappers` to regenerate."""
                import pytest
                from functional_tests.tools.runner import RunnerTool


                {markers}
                class TestClass{test_class_name}:
            "#,
        ),
        markers = markers,
        test_class_name = uppercase_first_letter(test_class_name)
    );

    let class_suffix = test_cases
        .iter()
        .map(serialize_pytest_wrapper_for_test_case)
        .join("\n");

    class_prefix + &class_suffix
}

/// Generates pytest test case (as part of a test class)
fn serialize_pytest_wrapper_for_test_case(test_case: &TestCaseMetadataInt) -> String {
    let markers = create_markers(vec![
        match test_case.type_ {
            "" | "functional" => "functional",
            _ => panic!("unexpected test case type: {}", test_case.type_),
        },
        match test_case.negative {
            true => "negative",
            false => "positive",
        },
        match test_case.feature {
            "" => "core",
            feature => feature,
        },
    ])
    .iter()
    .map(|marker| format!("    {}", marker))
    .join("\n");

    format!(
        indoc::indoc!(
            r#"
                {markers}
                    def {full_name}(
                        self,
                        vm,
                    ):
                        """Invokes {test_case} test case from {module} module located in {crate} crate."""

                        testRunner = RunnerTool(vm)
                        testRunner.run(
                            "{crate}",
                            "{module_no_crate}::{test_case}",
                        ),

                        pass
            "#,
        ),
        test_case = test_case.function,
        full_name = format!(
            "test_{}_{}",
            // skip the last module name, e.g. functional_tests, as that is redundant
            test_case
                .module
                .split("::")
                .collect::<Vec<_>>()
                .split_last()
                .unwrap()
                .1
                .join("_"),
            test_case.function.strip_prefix("test_").unwrap()
        ),
        module = test_case.module,
        module_no_crate = test_case.module.split("::").skip(1).join("::"),
        crate = test_case.crate_,
        markers = markers,
    )
}

/// Writes pytest test class wrapper to a `.py` file.
fn write_test_class_wrapper(py_wrapper_path: &Path, test_class_serialized: String) {
    let mut pytest_output = File::create(py_wrapper_path).unwrap();
    write!(pytest_output, "{}", test_class_serialized).unwrap();
}

/// Converts the first letter of the provided string to uppercase for nicer test class names.
// https://stackoverflow.com/a/38406885
fn uppercase_first_letter(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

/// Processes all entries registered with `inventory` and groups tests per
/// module. For every module, generates a test class containing all test cases
/// of that module. Such class is then stored in a per create directory in `.py`
/// file named based on the module name.
pub fn generate_pytest_wrappers() {
    let mut test_base_dir_path = PathBuf::from("functional_tests/generated");
    if !test_base_dir_path.exists() {
        test_base_dir_path = PathBuf::from("..").join(test_base_dir_path);

        if !test_base_dir_path.exists() {
            panic!("unexpected working directory: {:?}", env::current_dir());
        }
    }

    let test_classes = inventory::iter::<TestCaseMetadata>()
        .map(|tcm| TestCaseMetadataInt {
            // the inner most module is expected to be representing test class
            // name, e.g. functional_tests, so extract the test type from there
            crate_: tcm.module.split("::").next().unwrap(),
            module: tcm.module,
            function: tcm.function,
            type_: tcm.type_,
            negative: tcm.negative,
            feature: tcm.feature,
        })
        .group_by(|metadata| metadata.module);

    for (_, test_cases) in test_classes
        .into_iter()
        .map(|(name, group)| (name, group.collect::<Vec<_>>()))
    {
        let crate_ = test_cases[0].crate_;
        // skip the crate name
        // skip the functional_tests module name
        let test_class_name = test_cases[0]
            .module
            .split("::")
            .skip(1)
            .collect::<Vec<_>>()
            .split_last()
            .unwrap()
            .1
            .join("_");
        let serialized =
            serialize_pytest_wrapper_for_test_class(test_class_name.as_str(), test_cases);
        let test_class_dir_path = test_base_dir_path.join(crate_);
        fs::create_dir_all(&test_class_dir_path).unwrap();
        let py_wrapper_path = test_class_dir_path.join(format!("test_{test_class_name}.py"));
        write_test_class_wrapper(py_wrapper_path.as_path(), serialized);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_markers() {
        assert_eq!(
            create_markers(vec!["crate", "module", "functional", "negative", "core"]),
            vec![
                "@pytest.mark.core",
                "@pytest.mark.crate",
                "@pytest.mark.functional",
                "@pytest.mark.module",
                "@pytest.mark.negative",
            ]
        );
    }

    #[test]
    fn test_uppercase_first_letter() {
        assert_eq!(uppercase_first_letter("crate"), "Crate");
        assert_eq!(uppercase_first_letter("module"), "Module");
        assert_eq!(uppercase_first_letter("functional"), "Functional");
        assert_eq!(uppercase_first_letter("negative"), "Negative");
        assert_eq!(uppercase_first_letter("core"), "Core");
        assert_eq!(uppercase_first_letter(""), "");
    }

    #[test]
    fn test_serialize_pytest_wrapper_for_test_case() {
        let test_case = TestCaseMetadataInt {
            crate_: "osutils",
            module: "osutils::udevadm::functional_tests",
            function: "test_settle",
            type_: "functional",
            negative: false,
            feature: "helpers",
        };

        assert_eq!(
            serialize_pytest_wrapper_for_test_case(&test_case),
            indoc::indoc!(
                r#"
                    @pytest.mark.functional
                    @pytest.mark.helpers
                    @pytest.mark.positive
                    def test_osutils_udevadm_settle(
                        self,
                        vm,
                    ):
                        """Invokes test_settle test case from osutils::udevadm::functional_tests module located in osutils crate."""

                        testRunner = RunnerTool(vm)
                        testRunner.run(
                            "osutils",
                            "udevadm::functional_tests::test_settle",
                        ),

                        pass
                "#,
            ).split('\n').map(|l| format!("    {l}").trim_end().to_owned()).join("\n"),
        );
    }

    #[test]
    #[should_panic(expected = "unexpected test case type: foobar")]
    fn test_serialize_pytest_wrapper_for_test_case_fails_with_bad_type() {
        let test_case = TestCaseMetadataInt {
            crate_: "osutils",
            module: "udevadm",
            function: "test_settle",
            type_: "foobar",
            negative: true,
            feature: "helpers",
        };

        serialize_pytest_wrapper_for_test_case(&test_case);
    }

    #[test]
    fn test_serialize_pytest_wrapper_for_test_class() {
        let test_cases = vec![
            TestCaseMetadataInt {
                crate_: "osutils",
                module: "osutils::udevadm::functional_tests",
                function: "test_settle",
                type_: "functional",
                negative: true,
                feature: "helpers",
            },
            TestCaseMetadataInt {
                crate_: "osutils",
                module: "udevadm",
                function: "test_trigger",
                type_: "functional",
                negative: false,
                feature: "helpers",
            },
        ];

        assert_eq!(
            serialize_pytest_wrapper_for_test_class("udevadm", test_cases),
            indoc::indoc!(
                r#"
                    """Autogenerated from Rust code. Do not edit manually. Run `make generate-pytest-wrappers` to regenerate."""
                    import pytest
                    from functional_tests.tools.runner import RunnerTool


                    @pytest.mark.osutils
                    @pytest.mark.osutils_udevadm_functional_tests
                    class TestClassUdevadm:
                        @pytest.mark.functional
                        @pytest.mark.helpers
                        @pytest.mark.negative
                        def test_osutils_udevadm_settle(
                            self,
                            vm,
                        ):
                            """Invokes test_settle test case from osutils::udevadm::functional_tests module located in osutils crate."""

                            testRunner = RunnerTool(vm)
                            testRunner.run(
                                "osutils",
                                "udevadm::functional_tests::test_settle",
                            ),

                            pass

                        @pytest.mark.functional
                        @pytest.mark.helpers
                        @pytest.mark.positive
                        def test__trigger(
                            self,
                            vm,
                        ):
                            """Invokes test_trigger test case from udevadm module located in osutils crate."""

                            testRunner = RunnerTool(vm)
                            testRunner.run(
                                "osutils",
                                "::test_trigger",
                            ),

                            pass
                "#,
            ),
        );
    }
}
