use std::collections::HashMap;

use netplan_types::{
    CommonPropertiesAllDevices, CommonPropertiesPhysicalDeviceType, EthernetConfig, MatchConfig,
    NetworkConfig,
};
use trident_api::config::{
    AbUpdate, AbVolumePair, Disk, HostConfiguration, Image, ImageFormat, Imaging, MountPoint,
    OsConfig, Partition, PartitionSize, PartitionTableType, PartitionType, RaidConfig, RaidLevel,
    Script, SoftwareRaidArray, SshMode, Storage, User,
};

fn main() {
    println!(
        "# THIS FILE IS AUTOMATICALLY GENERATED BY {}\n# DO NOT EDIT MANUALLY!\n\n{}",
        file!(),
        serde_yaml::to_string(&build_host_configuration()).unwrap()
    );
}

fn build_host_configuration() -> HostConfiguration {
    HostConfiguration {
        storage: Storage {
            disks: vec![Disk {
                id: "os".to_string(),
                device: "/dev/disk/by-path/pci-0000:00:1f.2-ata-1.0".into(),
                partition_table_type: PartitionTableType::Gpt,
                partitions: vec![
                    Partition {
                        id: "esp".to_string(),
                        partition_type: PartitionType::Esp,
                        size: PartitionSize::Fixed(0x40000000), // 1GiB
                    },
                    Partition {
                        id: "root-a".to_string(),
                        partition_type: PartitionType::Root,
                        size: PartitionSize::Fixed(0x200000000), // 8GiB
                    },
                    Partition {
                        id: "root-b".to_string(),
                        partition_type: PartitionType::Root,
                        size: PartitionSize::Fixed(0x200000000), // 8GiB
                    },
                    Partition {
                        id: "swap".to_string(),
                        partition_type: PartitionType::Swap,
                        size: PartitionSize::Fixed(0x80000000), // 2GiB
                    },
                    Partition {
                        id: "trident".to_string(),
                        partition_type: PartitionType::LinuxGeneric,
                        size: PartitionSize::Fixed(0x40000000), // 1GiB
                    },
                    Partition {
                        id: "raid-a".to_string(),
                        partition_type: PartitionType::LinuxGeneric,
                        size: PartitionSize::Fixed(0x40000000), // 1GiB
                    },
                    Partition {
                        id: "raid-b".to_string(),
                        partition_type: PartitionType::LinuxGeneric,
                        size: PartitionSize::Fixed(0x40000000), // 1GiB
                    },
                ],
            }],
            raid: RaidConfig {
                software: vec![SoftwareRaidArray {
                    id: "some_raid".to_string(),
                    name: "some_raid1".to_string(),
                    level: RaidLevel::Raid1,
                    devices: vec!["raid-a".to_string(), "raid-b".to_string()],
                    metadata_version: "1.0".into(),
                }],
            },
            mount_points: vec![
                MountPoint {
                    path: "/boot/efi".into(),
                    target_id: "esp".into(),
                    filesystem: "vfat".into(),
                    options: vec!["umask=0077".into()],
                },
                MountPoint {
                    path: "/".into(),
                    target_id: "root".into(),
                    filesystem: "ext4".into(),
                    options: vec!["defaults".into()],
                },
                MountPoint {
                    path: "/var/lib/trident".into(),
                    target_id: "trident".into(),
                    filesystem: "ext4".into(),
                    options: vec!["defaults".into()],
                },
                MountPoint {
                    path: "none".into(),
                    target_id: "swap".into(),
                    filesystem: "swap".into(),
                    options: vec!["sw".into()],
                },
                MountPoint {
                    path: "/mnt/raid".into(),
                    target_id: "some_raid".into(),
                    filesystem: "ext4".into(),
                    options: vec!["defaults".into()],
                },
            ],
        },
        imaging: Imaging {
            images: vec![
                Image {
                    url: "file:///boot.raw.zst".into(),
                    sha256: "cd93c867cb0238fecb3bc9a268092526ba5f5b351bb17e5aab6fa0a9fc2ae4f8"
                        .into(),
                    format: ImageFormat::RawZstd,
                    target_id: "esp".into(),
                },
                Image {
                    url: "file:///root.raw.zst".into(),
                    sha256: "fef89794407c89e985deed49c14af882b7abe425c626b0a1a370b286dfa4d28d"
                        .into(),
                    format: ImageFormat::RawZstd,
                    target_id: "root".into(),
                },
            ],
            ab_update: Some(AbUpdate {
                volume_pairs: vec![AbVolumePair {
                    id: "root".into(),
                    volume_a_id: "root-a".into(),
                    volume_b_id: "root-b".into(),
                }],
            }),
        },
        network: Some(NetworkConfig {
            version: 2,
            ethernets: Some(HashMap::from([(
                "vmeths".into(),
                EthernetConfig {
                    common_all: Some(CommonPropertiesAllDevices {
                        dhcp4: Some(true),
                        ..Default::default()
                    }),
                    common_physical: Some(CommonPropertiesPhysicalDeviceType {
                        r#match: Some(MatchConfig {
                            name: Some("enp*".into()),
                            ..Default::default()
                        }),
                        ..Default::default()
                    }),
                    ..Default::default()
                },
            )])),
            ..Default::default()
        }),
        osconfig: OsConfig {
            users: HashMap::from([(
                "my-new-user".into(),
                User {
                    ssh_keys: vec!["<MY_PUBLIC_SSH_KEY>".into()],
                    ssh_mode: SshMode::KeyOnly,
                    ..Default::default()
                },
            )]),
        },
        post_install_scripts: vec![Script {
            content: "echo \"my-new-user ALL=(ALL) NOPASSWD:ALL\" > /etc/sudoers.d/my-new-user"
                .into(),
            interpreter: None,
            log_file_path: None,
        }],
        ..Default::default()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// This test is mostly to ensure that we try to build a host configuration
    /// and fail if the build fails to let us know that the sample is out of date.
    #[test]
    fn test_build_host_configuration() {
        let host_configuration = build_host_configuration();
        assert_eq!(host_configuration.storage.disks.len(), 1);
        assert_eq!(host_configuration.storage.raid.software.len(), 1);
        assert_eq!(host_configuration.storage.mount_points.len(), 5);
        assert_eq!(host_configuration.imaging.images.len(), 2);
        assert!(host_configuration.imaging.ab_update.is_some());
        assert!(host_configuration.network.is_some());
        assert_eq!(host_configuration.osconfig.users.len(), 1);
    }
}
